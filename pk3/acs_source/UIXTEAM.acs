#library "UIXTEAM"

#include "zcommon.acs"

#include "SHRTFUNC.acs"

#define TEAMINFO_ID_OFFS    10000
#define TEAMINFO_ID_NAME    0100
#define TEAMINFO_ID_HP1     0200
#define TEAMINFO_ID_HP2     0300
#define TEAMINFO_ID_HP3     0400
#define TEAMINFO_ID_WEI     0500
#define TEAMINFO_ID_WE1     0600
#define TEAMINFO_ID_WE2     0700
#define TEAMINFO_ID_LOC     0800
#define TEAMINFO_ID_ARR1    0900
#define TEAMINFO_ID_ARR2    1000
#define TEAMINFO_ID_ARR3    1100
#define TEAMINFO_ID_ARR4    1200
#define TEAMINFO_ID_ARR5    1300
#define TEAMINFO_ID_ARR6    1400
#define TEAMINFO_ID_MUG     1500

#define TEAMINFO_BAR_FONT 0
#define TEAMINFO_BAR_START 2
#define TEAMINFO_BAR_MAX 5

#define TEAMINFO_BARMAX 100

#define horizontal 0
#define vertical 1

int cvOffsx;
int cvOffsy;
int cvScale;
int cvAlpha;
int cvNamesize;
int cvMirror;
int cvDir;
int cvFontdir;
int cvStack;
int cvShowname;
int cvShowhealth;
int cvShowlocation;
int cvShowcompass;
int cvShowmugshot;

int tiCache_Scale = MIN_INT;
int tiCache_Stack = MIN_INT;

#define STACK_OFFS 36
int tiStackOffs;

script "UITweaks_TeamInfo" (int cam, int cpn, int cv)
{
    if(!GetCvar("UIX_SV_TEAMINFO"))
        terminate;

    int baseAlpha = GetUserCvar(cpn, "UIX_CL_TEAMINFOALPHA");
    if(baseAlpha == 0.0)
        terminate;

    if(CheckActorInventory(cam, "UIX_NoTeamBar") > 0)
        terminate;

    SetActivator(cam);

    int pln = PlayerNumber();
    if(pln == -1)
        terminate;

    SetActivator(-1);

    int team = getPlayerTeam(pln);
    // Log(i:team, s:" cam: ", i:cam);

    if(team == 255) { // Spectator

    } else {
        cvOffsx = GetUserCvar(cpn, "UIX_CL_TEAMINFOOFFSX");
        cvOffsy = GetUserCvar(cpn, "UIX_CL_TEAMINFOOFFSY");
        cvScale = GetUserCvar(cpn, "UIX_CL_TEAMINFOSCALE");
        cvAlpha = baseAlpha;
        cvNamesize = GetUserCvar(cpn, "UIX_CL_TEAMINFONAMESIZE");
        cvMirror = GetUserCvar(cpn, "UIX_CL_TEAMINFOMIRROR");
        cvDir = GetUserCvar(cpn, "UIX_CL_TEAMINFODIR");
        cvFontdir = GetUserCvar(cpn, "UIX_CL_TEAMINFOFONTDIR");
        cvStack = GetUserCvar(cpn, "UIX_CL_TEAMINFOSTACK");
        cvShowname = GetUserCvar(cpn, "UIX_CL_TEAMINFOSHOWNAME");
        cvShowhealth = GetUserCvar(cpn, "UIX_CL_TEAMINFOSHOWHEALTH");
        cvShowlocation = GetUserCvar(cpn, "UIX_CL_TEAMINFOSHOWLOCATION");
        cvShowcompass = GetUserCvar(cpn, "UIX_CL_TEAMINFOSHOWCOMPASS");
        cvShowmugshot = GetUserCvar(cpn, "UIX_CL_TEAMINFOSHOWMUGSHOT");

        if(tiCache_Scale != cvScale || tiCache_Stack != cvStack)
        {
            tiCache_Scale = cvScale;
            tiCache_Stack = cvStack;

            tiStackOffs = (cvStack ? -1 : 1) * FixedMul(STACK_OFFS, cvScale);
        }

        int drawnPlayers = 0;

        for(int i = 0; i < MAX_PLAYERS_SHRT; i++) {
            // Log(i:i, s:" == ", i:pln);
            if(i == pln)
                continue;

            // Log(i:i, s:"in game? ", i:PlayerInGame(i));
            if(!PlayerInGame(i))
                continue;

            // Log(i:i, s:" team: ", i:GetPlayerInfo(i, PLAYERINFO_TEAM), s:" == ", i:team);
            if(getPlayerTeam(i) != team)
                continue;

            int baseX = cvOffsx + (cvDir ? drawnPlayers * tiStackOffs : 0);
            int baseY = cvOffsy + (!cvDir ? drawnPlayers * tiStackOffs : 0);

            drawMugshot(i, baseX, baseY);
            drawName(i, baseX, baseY);
            // drawLocation(i, baseX, baseY);
            drawHealth(i, baseX, baseY);
            // drawWeapon(i, baseX, baseY);

            drawnPlayers++;

    //         int mhp = GetActorProperty(plrTid, AProp_SpawnHealth);
    //         if(drawHealth && mhp > 0) {
    //             int chp = GetActorProperty(plrTid, AProp_Health);

    //             int hpWidth = orientation ? 80 : 640;
    //             int hpHeight = orientation ? 640 : 80;

    //             int hpTop = orientation ? "UXTEMHV1" : "UXTEMHH1";
    //             int hpBot = orientation ? "UXTEMHVB" : "UXTEMHHB";

    //             int barScale = FixedMul(FixedMul(baseScale, 1.0), 0.1);
    //             drawBar(hpTop, hpBot, barX, barY, hpWidth, hpHeight, barScale, barScale, baseAlpha, chp, mhp, sbar_orientation, false, getNewUIId(), getNewUIId());
    //         }

    //         if(drawWeapon) {
    //             int amt1, amt2, amx1, amx2, cyan, cyan2, blue, blue2, black, icon, iconScale, weapBarScale;

    //             iconScale = FixedMul(baseScale, 0.5);
    //             weapBarScale = FixedMul(baseScale, 0.1);

    //             icon = ACS_NamedExecuteWithResult("UIXDB_GetPlayerWeaponProperty", i, UIX_WeapProp_Icon);
    //             cyan = ACS_NamedExecuteWithResult("UIXDB_GetAmmoBar", orientation, 0, ACS_NamedExecuteWithResult("UIXDB_GetPlayerWeaponProperty", i, UIX_WeapProp_Cyan));
    //             blue = ACS_NamedExecuteWithResult("UIXDB_GetAmmoBar", orientation, 1, ACS_NamedExecuteWithResult("UIXDB_GetPlayerWeaponProperty", i, UIX_WeapProp_Blue));
    //             black = ACS_NamedExecuteWithResult("UIXDB_GetAmmoBar", orientation, 2);

    //             amt1 = ACS_NamedExecuteWithResult("UIXDB_GetPlayerAmmo", i, 0, 0);
    //             amx1 = ACS_NamedExecuteWithResult("UIXDB_GetPlayerAmmo", i, 0, 1);

    //             amt2 = ACS_NamedExecuteWithResult("UIXDB_GetPlayerAmmo", i, 1, 0);

    //             displayIcon(icon, getNewUIId(), wepIconX, wepIconY, iconScale, iconScale, baseAlpha);

    //             if(amt2 != -1) {
    //                 amx2 = ACS_NamedExecuteWithResult("UIXDB_GetPlayerAmmo", i, 1, 1);
    //                 cyan2 = ACS_NamedExecuteWithResult("UIXDB_GetAmmoBar", orientation, 0, ACS_NamedExecuteWithResult("UIXDB_GetPlayerWeaponProperty", i, UIX_WeapProp_Cyan2));
    //                 blue2 = ACS_NamedExecuteWithResult("UIXDB_GetAmmoBar", orientation, 1, ACS_NamedExecuteWithResult("UIXDB_GetPlayerWeaponProperty", i, UIX_WeapProp_Blue2));

    //                 drawLayeredBar(cyan, blue, black, wepBar1X, wepBar1Y, 160, 40, weapBarScale, weapBarScale, baseAlpha, amt1, amx1, sbar_orientation, false, getNewUIId(), getNewUIId(), getNewUIId());
    //                 drawLayeredBar(cyan2, blue2, black, wepBar2X, wepBar2Y, 160, 40, weapBarScale, weapBarScale, baseAlpha, amt1, amx1, sbar_orientation, false, getNewUIId(), getNewUIId(), getNewUIId());
    //             } else {
    //                 drawLayeredBar(cyan, blue, black, wepBarX, wepBarY, 160, 40, weapBarScale, weapBarScale, baseAlpha, amt1, amx1, sbar_orientation, false, getNewUIId(), getNewUIId(), getNewUIId());
    //             }
    //         }

    //         if(drawMugshot) {
    //             str face = getMugshotGraphicFromTID(plrTid);
    //             int faceScale = FixedMul(baseScale, 4.0);
    //             if(face != 0)
    //                 if(StrLen(face) > 0)
    //                     displayIcon(face, getNewUIId(), mugX, mugY, faceScale, faceScale, baseAlpha);
    //         }

    //         // if(wep != -1) {
    //         //     int ammo = getWeaponAmmoType(wep);
    //         //     int mwe = getPlayerAmmoCapacity(i, ammo);
    //         //     int cwe = checkActorInventory(i+PLN_TID_SHRT, ammo);
    //         //     // PrintBold(i:mwe);
    //         //     displayIcon(getWeaponIcon(wep), curId+TEAMINFO_ID_WEI, barX+16, barY+32, 1.0, 1.0, 1.0);
    //         //     displayHBar("UIXWEFH", "UIXHPBH", cwe, mwe, curId+TEAMINFO_ID_WE1, curId+TEAMINFO_ID_WE2, barX+16, barY+16, 1.0, 1.0, 1.0);
    //         // }

    //         curPlay++;
        }
    }
}

// Generic Draw constants ===========================================================================================================================
#define ROW_LENGTH 9

// Draw mugshot =====================================================================================================================================
int mugCache_Scale = 0;
int mugScale;

function void drawMugshot(int pln, int x, int y)
{
    if(!cvShowmugshot)
        return;

    str face = getMugshotGraphicFromTID(pln+PLN_TID_SHRT);

    if(face == 0)
        return;

    if(StrLen(face) == 0)
        return;

    if(mugCache_Scale != cvScale) {
        mugCache_Scale = cvScale;
        mugScale = FixedMul(cvScale, 4.0);
    }

    displayIcon(face, getNewUIId(), x, y, mugScale, mugScale, cvAlpha);
}

// Mugshot data pull, from pingbutton
function str getMugshotGraphicFromTID(int tid) {
	str class = GetActorClass(tid);

	int u = UniqueTID();
	if(!SpawnForced(StrParam(s:"PBMug_", s:class), 0, 0, 0, u, 0)) {
		return "";
	}
	Thing_Remove(u);

	return ACS_NamedExecuteWithResult(StrParam(s:"PBMug_", s:class), tid);
}

// Draw Name ========================================================================================================================================
#define TEXT_SCALE 0.7

#define NAME_X_00 16
#define NAME_Y_00 -10

#define NAME_X_01 0
#define NAME_Y_01 0

#define NAME_X_10 0
#define NAME_Y_10 0

#define NAME_X_11 0
#define NAME_Y_11 0

str nameFonts[2] = {
    "SMALLFNT",
    "SIDEFNTL",
};

int nameCache_Scale;
int nameCache_Mirror;
int nameCache_Dir;

int nameCache_Namesize;

int nameX;
int nameY;
int nameScale;
int nameHAlign;
int nameVAlign;

int nameLength;

function void drawName(int pln, int x, int y)
{
    if(!cvShowName)
        return;

    if(
        nameCache_Scale != cvScale ||
        nameCache_Mirror != cvMirror ||
        nameCache_Dir != cvDir ||
        nameCache_Namesize != cvNamesize
    )
    {
        nameCache_Scale = cvScale;
        nameCache_Mirror = cvMirror;
        nameCache_Dir = cvDir;
        nameCache_Namesize = cvNamesize;

        nameX = FixedMul(cvScale, (!cvDir ? (!cvMirror ? NAME_X_00 : NAME_X_01) : (!cvMirror ? NAME_X_10 : NAME_X_11)));
        nameY = FixedMul(cvScale, (!cvDir ? (!cvMirror ? NAME_Y_00 : NAME_Y_01) : (!cvMirror ? NAME_Y_10 : NAME_Y_11)));
        nameScale = FixedMul(cvScale, TEXT_SCALE);
        nameLength = cvNamesize; // FixedDiv(cvNamesize, TEXT_SCALE);
        nameHAlign = cvMirror && cvDir == horizontal ? ALIGN_RIGHT : ALIGN_LEFT;
        nameVAlign = cvMirror && cvDir == vertical ? ALIGN_BOTTOM : ALIGN_TOP;
    }

    str name = getPlayerName(pln, cvDir, cvMirror);
    int plrNameLength = getCacheNameWidth(pln, cvDir, cvFontdir);
    int nameLengthScale = 1.0;

    if(plrNameLength > nameLength) {
        nameLengthScale = FixedDiv(nameLength, plrNameLength);
    }

    int nameScaleX = cvDir ? nameScale : FixedMul(nameScale, nameLengthScale);
    int nameScaleY = !cvDir ? nameScale : FixedMul(nameScale, nameLengthScale);
    
    SetFont(nameFonts[cvFontdir]);
    displayMessage(name, getNewUIId(), x + nameX, y + nameY, nameScaleX, nameScaleY, cvAlpha, nameHAlign, nameVAlign);
}

// Draw Health ======================================================================================================================================
#define HP_X_00 16
#define HP_Y_00 -20+2*ROW_LENGTH

#define HP_X_01 0
#define HP_Y_01 0

#define HP_X_10 0
#define HP_Y_10 0

#define HP_X_11 0
#define HP_Y_11 0

int healthCache_Scale;
int healthCache_Mirror;
int healthCache_Dir;

int healthX;
int healthY;
int healthScale;
int healthWidth;
int healthHeight;
int healthTop;
int healthBottom;

str healthBars[2][2] = {
    {"UXTEMHH1", "UXTEMHV1"},
    {"UXTEMHHB", "UXTEMHVB"}
};

int healthBarDimensions[2] = {640, 80};

function void drawHealth(int pln, int x, int y)
{
    if(!cvShowName)
        return;

    int mhp = GetActorProperty(pln+PLN_TID_SHRT, AProp_SpawnHealth);
    if(mhp == 0)
        return;

    if(
        healthCache_Scale != cvScale ||
        healthCache_Mirror != cvMirror ||
        healthCache_Dir != cvDir
    )
    {
        healthCache_Scale = cvScale;
        healthCache_Mirror = cvMirror;
        healthCache_Dir = cvDir;

        healthX = FixedMul(cvScale, (!cvDir ? (!cvMirror ? HP_X_00 : HP_X_01) : (!cvMirror ? HP_X_10 : HP_X_11)));
        healthY = FixedMul(cvScale, (!cvDir ? (!cvMirror ? HP_Y_00 : HP_Y_01) : (!cvMirror ? HP_Y_10 : HP_Y_11)));
        healthScale = FixedMul(FixedMul(cvScale, 1.0), 0.1);
    }
    
    int chp = GetActorProperty(pln+PLN_TID_SHRT, AProp_Health);

    drawBar(healthBars[0][cvDir], healthBars[1][cvDir], x+healthX, y+healthY, healthBarDimensions[cvDir], healthBarDimensions[!cvDir], healthScale, healthScale, cvAlpha, chp, mhp, !cvDir+1, false, getNewUIId(), getNewUIId());
}

// Player name cache ================================================================================================================================
#define NAME_MAX 1000
#define CHAR_COLOR 28

int nameSize;
int nameBuilder[NAME_MAX];

int nameColorless[NAME_MAX];
int nameColors[NAME_MAX];
int colorPos[NAME_MAX][3];

function int getColorPos(int i) { return colorPos[i][0]; }
function int getColorStart(int i) { return colorPos[i][1]; }
function int getColorEnd(int i) { return colorPos[i][2]; }

function void setColorPos(int i, int val) { colorPos[i][0] = val; }
function void setColorStart(int i, int val) { colorPos[i][1] = val; }
function void setColorEnd(int i, int val) { colorPos[i][2] = val; }

// output of rebuildString stored here.
str cacheKey;
str cacheVert;
str cacheVertReverse;
int cacheWidth;
int cacheHeight;
int cacheHeightReverse;

function void rebuildString(str name) {
    cacheKey = name;

    strCpy(a:nameBuilder, name);
    nameSize = StrLen(name);

    str outName = "";

    int inColor = 0;
    int colorStart;

    int colorLessSize = 0;
    int colorsLength = 0;
    int colorsCount = 0;

    int i;

    int nameWidth = 0;

    for(i = 0; i < nameSize; i++) {
        switch(inColor) {
            case 0:
                if(nameBuilder[i] == CHAR_COLOR) {
                    inColor = 1;
                    setColorPos(colorsCount, colorLessSize);
                    setColorStart(colorsCount, colorsLength);
                } else {
                    nameColorless[colorLessSize++] = nameBuilder[i];
                    nameWidth += getCharWidth(nameBuilder[i]);
                }
                break;
            case 1: // check next char
                if(nameBuilder[i] == '[') {
                    colorStart = i;
                    inColor = 2;
                    setColorPos(colorsCount, colorLessSize);
                    setColorStart(colorsCount, colorsLength);
                    nameColors[colorsLength++] = nameBuilder[i];
                } else {
                    inColor = 0;
                    nameColors[colorsLength++] = nameBuilder[i];
                    setColorEnd(colorsCount, colorsLength);
                    colorsCount++;
                }
                break;
            case 2: // in big string
                nameColors[colorsLength++] = nameBuilder[i];
                if(nameBuilder[i] == ']') {
                    inColor = 0;
                    setColorEnd(colorsCount, colorsLength);
                    colorsCount++;
                }
                break;
        }
        nameBuilder[i] = 0;
    }

    // // Cache test
    // Log(a:(nameColorless, 0, colorLessSize));
    // Log(a:(nameColors, 0, colorsLength));

    // // Colors test
    // str tpos = StrParam(i:getColorPos(0));
    // str tstart = StrParam(i:getColorStart(0));
    // str tend = StrParam(i:getColorEnd(0));
    // for(i = 1; i < colorsCount; i++) {
    //     tpos = StrParam(s:tpos, s:", ", i:getColorPos(i));
    //     tstart = StrParam(s:tstart, s:", ", i:getColorStart(i));
    //     tend = StrParam(s:tend, s:", ", i:getColorEnd(i));
    // }
    // Log(s:tstart);
    // Log(s:tend);
    // Log(s:tpos);

    int c, nidx, curCol;

    // vertical
    nidx = 0;
    curCol = -1;
    for(i = 0; i < colorLessSize; i++) {
        if(i == getColorPos(curCol+1)) {
            curCol++;
        }

        if(nameColorless[i] != ' ') {
            if(curCol > -1) {
                nameBuilder[nidx++] = CHAR_COLOR;
                for(c = getColorStart(curCol); c < getColorEnd(curCol); c++) {
                    nameBuilder[nidx++] = nameColors[c];
                }
            }
            nameBuilder[nidx++] = nameColorless[i];
        }

        nameBuilder[nidx++] = '\n';
    }

    cacheVert = StrParam(a:(nameBuilder, 0, nidx));
    
    // verticalreverse
    nidx = 0;
    curCol = colorsCount-1;
    for(i = colorLessSize; i > 0; i--) {
        if(i == getColorPos(curCol)) {
            curCol--;
        }

        if(nameColorless[i-1] != ' ') {
            if(curCol < colorsCount) {
                nameBuilder[nidx++] = CHAR_COLOR;
                for(c = getColorStart(curCol); c < getColorEnd(curCol); c++) {
                    nameBuilder[nidx++] = nameColors[c];
                }
            }
            nameBuilder[nidx++] = nameColorless[i-1];
        }

        nameBuilder[nidx++] = '\n';
    }

    cacheVertReverse = StrParam(a:(nameBuilder, 0, nidx));
    cacheWidth = nameWidth;
    cacheHeight = colorLessSize * 11;
    cacheHeightReverse = colorLessSize * 9;
}

// bool init
// string name
// string vertical
// string reversevertical
// int width horizontal
// int width vertical
// int width vertical reverse
//
str namesCache[64][7];

function int isCacheInit(int plr) { return namesCache[plr][0]; }
function void setCacheInit(int plr, int val) { namesCache[plr][0] = val; }

function str getCacheName(int plr, int o, int r) { return namesCache[plr][1 + (o ? o + r : 0)]; }
function void setCacheName(int plr, int o, int r, str val) { namesCache[plr][1 + (o ? o + r : 0)] = val; }

function int getCacheNameWidth(int plr, int o, int r) { return namesCache[plr][5 + (o ? o + r : 0)]; }
function void setCacheNameWidth(int plr, int o, int r, int val) { namesCache[plr][5 + (o ? o + r : 0)] = val; }

function bool needsReset(int plr, str name)
{
    // [Russ] keeping in pattern with other uix stuff, short circuit the most important fail case
    if(!isCacheInit(plr)) {
        return true;
    }

    if(StrCmp(name, getCacheName(plr, 0, 0)) != 0) {
        return true;
    }

    return false;
}

function str getPlayerName(int plr, int o, int r)
{
    str name = StrParam(n:1+plr);

    if(needsReset(plr, name)) {
        rebuildString(name);

        setCacheInit(plr, true);
        setCacheName(plr, false, false, cacheKey);
        setCacheName(plr, true, false, cacheVert);
        setCacheName(plr, true, true, cacheVertReverse);
        setCacheNameWidth(plr, false, false, cacheWidth);
        setCacheNameWidth(plr, true, false, cacheHeight);
        setCacheNameWidth(plr, true, true, cacheHeightReverse);
    }

    return getCacheName(plr, o, r);
}

#define LOC_SIZE_LIMIT 1000
int LOC_SIZE = 0;

// Location name cache ==============================================================================================================================
// string location
// string vertical
// string reversevertical
// int width horizontal
// int width vertical
// int width vertical reverse
//
// Index size +1 to append an error state for the last slot
str locs[LOC_SIZE_LIMIT+1][7];

// previous locations so per-tic comparisons are reduced
// int loc
// int idx
//
int playerLocs[64][2];

// [Russ] This algorithm is based on one very dangerous assumption.
// Will the engine generate an identical string with a separate index in the string table?
// I feel like only god knows.
// And Graf Zahl in the year 2013, but no one really cares about his opinion anymore.
//
function int findLoc(int id) {
    for(int i = 0; i < LOC_SIZE; i++) {
        if(getLocId(i) == id)
            return i;
    }
    return -1;
}

function int getLocId(int idx) { return namesCache[idx][0]; }
function void setLocId(int idx, int val) { namesCache[idx][0] = val; }

function str getLocName(int idx, int o, int r) { return namesCache[idx][(o ? o + r : 0)]; }
function void setLocName(int idx, int o, int r, str val) { namesCache[idx][(o ? o + r : 0)] = val; }

function int getLocNameWidth(int idx, int o, int r) { return namesCache[idx][4 + (o ? o + r : 0)]; }
function void setLocNameWidth(int idx, int o, int r, int val) { namesCache[idx][4 + (o ? o + r : 0)] = val; }

function str findLocation(int plr, int o, int r) {
    str loc = GetActorSectorLocation(plr+PLN_TID_SHRT, false);

    if(StrLen(loc) == 0)
        return -1;

    if(playerLocs[plr][0] == loc)
        return getLocName(playerLocs[plr][1], o, r);

    int idx = findLoc(loc);

    if(idx != -1) {
        playerLocs[plr][0] = loc;
        playerLocs[plr][1] = idx;
        return getLocName(idx, o, r);
    }

    if(LOC_SIZE > LOC_SIZE_LIMIT) {
        playerLocs[plr][0] = loc;
        playerLocs[plr][1] = LOC_SIZE_LIMIT;
        return getLocName(LOC_SIZE_LIMIT, o, r);
    }
    
    if(LOC_SIZE == LOC_SIZE_LIMIT) {
        loc = StrParam(l:StrParam(s:"UIX_UNKNOWN_LOC_", i:random(1, 4)));
    }

    rebuildString(loc);

    setLocName(idx, false, false, cacheKey);
    setLocName(idx, true, false, cacheVert);
    setLocName(idx, true, true, cacheVertReverse);
    setLocNameWidth(idx, false, false, cacheWidth);
    setLocNameWidth(idx, true, false, cacheHeight);
    setLocNameWidth(idx, true, true, cacheHeightReverse);

    playerLocs[plr][0] = loc;
    playerLocs[plr][1] = LOC_SIZE;

    return getLocName(LOC_SIZE++, o, r);
}

// Character width calculator =======================================================================================================================

int fontCharWidths[256] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
};

function int getCharWidth(int char) {
    int idx = char + 128;
    if(fontCharWidths[idx] >= 0)
        return fontCharWidths[idx];

    int width = parseInt(StrParam(l:StrParam(s:"UI_SMALLFONT_", c:char<0?'N':'P', i:char)));
    fontCharWidths[idx] = width;
    return width;
}

// function str rotateLocation(int tid, int vert)
// {
//     str loc = GetActorSectorLocation(tid, false);

//     if(StrLen(loc) == 0)
//         return 0;

//     loc = StrParam(s:"\cf(", s:loc, s:"\cf)");

//     if(!vert)
//         return loc;

//     int idx = findLoc(loc);

//     bool update = false;

//     if(idx == -1)
//         update = true;

//     int cv = GetUserCvar(ConsolePlayerNumber(), "UIX_CL_TEAMINFOFONTDIR");

//     if(!update)
//         if(locs[idx][2] != cv)
//             update = true;

//     if(update) {
//         if(idx == -1)
//             idx = LOC_SIZE++;

//         locs[idx][0] = loc;
//         locs[idx][1] = rebuildName(loc, cv);
//         locs[idx][2] = cv;
//     }

//     return locs[idx][1];
// }

// function int findLoc(str loc) {
//     for(int i = 0; i < LOC_SIZE; i++) {
//         if(StrCmp(loc, locs[i][0])==0) {
//             return i;
//         }
//     }
//     return -1;
// }

function int getPlayerNameLength(int plr, int vert) {
    return 0;
}

// [russ] surely i'll redo this cache system at some point to actually work smarter not harder
// int nameLengths[MAX_PLAYERS_SHRT][3];

// function int getPlayerNameLength(int plr, int vert) {
//     str name = StrParam(n:1+plr);

//     if(StrCmp(nameLengths[plr][2], name) != 0) {
//         strCpy(a:nameBuilder, name);
//         nameSize = StrLen(name);

//         str outName = "";

//         int inColor = 0;
//         int colorStart;

//         int colorLessSize = 0;
//         int colorSize = 0;

//         int i;

//         int vertLen = 0;
//         int horzLen = 0;

//         for(i = 0; i < nameSize; i++) {
//             switch(inColor) {
//                 case 0:
//                     if(nameBuilder[i] == CHAR_COLOR) {
//                         colorPos[colorSize] = colorLessSize;
//                         inColor = 1;
//                     } else {
//                         horzLen += charWidths[nameBuilder[i]];
//                         vertLen += 9;
//                     }
//                     break;
//                 case 1: // check next char
//                     if(nameBuilder[i] == '[') {
//                         colorStart = i;
//                         inColor = 2;
//                     } else {
//                         inColor = 0;
//                     }
//                     break;
//                 case 2: // in big string
//                     if(nameBuilder[i] == ']') {
//                         inColor = 0;
//                     }
//                     break;
//             }
//         }

//         nameLengths[plr][0] = horzLen;
//         nameLengths[plr][1] = vertLen;
//     }

//     return nameLengths[plr][vert];
// }
